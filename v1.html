<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Encrypted - v1</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="encrypt">
        <div id="encrypt-create">
          <form id="encrypt-create-form">
            <textarea id="encrypt-create-text"></textarea>
            <input id="encrypt-create-password" type="password" />
            <button type="submit" id="encrypt-create-submit">Encrypt</button>
          </form>
        </div>
        <div id="encrypt-success">
          <input type="text" disabled id="encrypt-success-url" />
          <button type="button" id="encrypt-success-copy">Copy</button>
        </div>
      </div>
      <div id="decrypt">
        <div id="decrypt-locked">
          <form id="decrypt-locked-form">
            <input id="decrypt-locked-password" type="password" />
            <button type="submit" id="decrypt-locked-submit">Decrypt</button>
            <div id="decrypt-locked-error"></div>
          </form>
        </div>
        <div id="decrypt-unlocked">
          <div id="decrypt-unlocked-content"></div>
        </div>
      </div>
    </div>

    <script>
      // Derive encryption key from password
      async function deriveKey(password, salt) {
        const passwordKey = await crypto.subtle.importKey(
          "raw",
          strToArrayBuffer(password),
          "PBKDF2",
          false,
          ["deriveKey"],
        );

        return crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256",
          },
          passwordKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"],
        );
      }

      // Encrypt content
      async function encrypt(text, password) {
        assert(password, "Password is required");
        assert(text, "Text is required");
        assert(typeof text === "string", "Text must be a string");
        assert(typeof password === "string", "Password must be a string");

        try {
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const key = await deriveKey(password, salt);

          const encrypted = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            strToArrayBuffer(text),
          );

          // Combine salt + iv + encrypted data
          const combined = new Uint8Array(
            salt.length + iv.length + encrypted.byteLength,
          );
          combined.set(salt, 0);
          combined.set(iv, salt.length);
          combined.set(new Uint8Array(encrypted), salt.length + iv.length);

          return {
            ok: true,
            data: arrayBufferToBase64(combined.buffer),
          };
        } catch (error) {
          console.error("Encryption error:", error);
          return { ok: false, error: error.message };
        }
      }

      // Decrypt content
      async function decrypt(encryptedData, password) {
        assert(password, "Password is required");
        assert(encryptedData, "Encrypted data is required");
        assert(
          typeof encryptedData === "string",
          "Encrypted data must be a string",
        );
        assert(typeof password === "string", "Password must be a string");

        try {
          const combined = new Uint8Array(base64ToArrayBuffer(encryptedData));

          const salt = combined.slice(0, 16);
          const iv = combined.slice(16, 28);
          const encrypted = combined.slice(28);

          const key = await deriveKey(password, salt);

          const decrypted = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            key,
            encrypted,
          );

          return {
            ok: true,
            data: arrayBufferToString(decrypted),
          };
        } catch (error) {
          return { ok: false, error: error.message };
        }
      }

      function assert(condition, message) {
        if (!condition) {
          throw new Error(message);
        }
      }

      // Convert string to ArrayBuffer
      function strToArrayBuffer(str) {
        const encoder = new TextEncoder();
        return encoder.encode(str);
      }

      // Convert ArrayBuffer to string
      function arrayBufferToString(buffer) {
        const decoder = new TextDecoder();
        return decoder.decode(buffer);
      }

      // Convert ArrayBuffer to base64
      function arrayBufferToBase64(buffer) {
        return btoa(String.fromCharCode(...new Uint8Array(buffer)));
      }

      // Convert base64 to ArrayBuffer
      function base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function hashChanged() {
        console.log("hash changed");
      }

      // Initialize mode on load
      window.addEventListener("hashchange", hashChanged);
    </script>
  </body>
</html>
